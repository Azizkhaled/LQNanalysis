# SRVN Model Description File, for file: model.lqn
# Generated by: lqngen, version 5.24
# For: acer
# Sat Mar 19 22:09:26 2022
# Invoked as: lqngen model.lqn
# $Id$
# ------------------------------------------------------------------------
$ZU = 2000
$ConstructDynamic_SendStatic_Graphics = 23.8 # = 5 + 0.8 + K*1 + 0.25*(16+3*K), K = 8 
#$threads=[1,5,8,10]
$N=[1,5,10,50,75,100,125,150,175,200,300,400,450,500,550]

G "Layers: 1, Customers: 1, Clients: 1, Tasks: 1, (Delay: 0), Processors: 1" 	# Model comment 
1e-03			# Convergence test value.
50			# Maximum number of iterations.
10			# Print intermediate results (see manual pages)
0.9			# Model under-relaxation ( 0.0 < x <= 1.0)
-1

P 3
# SYNTAX: p ProcessorName SchedDiscipline [flags]
#   ProcessorName is any string, globally unique among processors.
#   SchedDiscipline = f {fifo}
#                   | r {random}
#                   | p {premptive}
#                   | h {hol (or non-pre-emptive priority)}
#                   | s <real> {processor-sharing (or round-robin) with quantum} 
#   flags = m <int> {multiprocessor}
#         | i {infinite or delay server}
#         | R <real> {rate multiplier}
  p PC f i 	# infinite processor for users
  p WSP f %u $uWSP 	# processor for “ProtocolStack”,
					# “WebServer”, "WSDisk" and “CGIApplication” 
  p DBP f %u $uDBP  # processor for database server,
					# and DBdisk		
-1

T 7
# SYNTAX: t TaskName TaskType EntryList -1 ProcessorName [flags]
#   TaskName is any string, globally unique among tasks.
#   TaskType = r {reference or user task}
#            | n {other} 
#   flags = m <int> {multithreaded}
#         | i {infinite or delay server}
#         | z <real> {think time}
#         | <int> {task priority}
  
  t USERS r users -1 PC z $ZU m $N %f $thru
  t ProtocolStack n PS -1 WSP %u $uProtocolStack
  t WebServer n CacheW DiskW -1 WSP %u $uWebServer
  t WSDisk n WSDread WSDwrite -1 WSP %u $uWSDisk
  t CGIApplication n T2 T3 -1 WSP %u $uCGIApplication
  t DataBaseServer n DBSUpdate DBSRead -1 DBP %u $uDBS
  t DBDisk n DBDread DBDwrite -1 DBP %u $uDBDisk 
-1

E 0
# SYNTAX-FORM-A: Token EntryName Value1 [Value2] [Value3] -1
#   EntryName is a string, globally unique over all entries 
#   Values are for phase 1, 2 and 3 {phase 1 is before the reply} 
#   Token indicate the significance of the Value: 
#       s - HostServiceDemand for EntryName 
#       c - HostServiceCoefficientofVariation
#       f - PhaseTypeFlag
# SYNTAX-FORM-B: Token FromEntry ToEntry Value1 [Value2] [Value3] -1
#   Token indicate the Value Definitions: 
#       y - SynchronousCalls {no. of rendezvous} 
#       F - ProbForwarding {forward to ToEntry rather than replying} 
#       z - AsynchronousCalls {no. of send-no-reply messages} 
# ---------- USERS ----------
  s users 1 -1 %s1 $rt
  #f users 1 -1 	#testing, copying from slide 43 
  y users PS 0.25 -1 
# ---------- ProtocolStack ----------
  A PS analyzestart		# Entry protocol analyze is defined using activties
# ---------- Webserver ----------
  s CacheW 1.0 -1 	
  s DiskW 1.0  -1
  y DiskW WSDread 3 -1 
# ---------- WSDisk ----------
  s WSDread 10.1 -1  # not clear if  it should be 0.1 or 10+0.1
  s WSDwrite 10.1 -1 # not clear if  it should be 0.1 or 10+0.1
# ---------- CGIApplication ----------
  s T2 15 -1
  s T3 $ConstructDynamic_SendStatic_Graphics -1
  y T2 DBSUpdate 1.7 -1
  y T3 DBSRead 4.3 -1
  y T3 WSDwrite 1.6 -1  # 0.2*8
# ---------- DataBaseServer ----------
  s DBSUpdate 30 -1 
  s DBSRead 20 -1 
  y DBSUpdate DBDread 2 -1
  y DBSUpdate DBDwrite 4  -1
  y DBSRead DBDread 4 -1
# ---------- DBDisk ----------
  s DBDread 10.1 -1  # not clear if  it should be 0.1 or 10+0.1
  s DBDwrite 10.1 -1 # not clear if  it should be 0.1 or 10+0.1  
-1


#Optional sections for definition of activities 
# a1 -> (prob2)a2 + (prob3)a3 ...OR fork (any number, 
# a1 -> a2 for sequence 

A ProtocolStack 
  s analyzestart 1 
  
  # Cache, Disk, type2 and type3  are just dummy entries to determine request type
  s Cache 0		
  s Disk 0		
  s type2 0 	
  s type3 0 
  
  # Send the dummy entry to the related task entry
  y Cache CacheW 1 
  y Disk DiskW 1 
  y type2 T2 1
  y type3 T3 1
  
  # result for sending a reply to the protocol stack 
  s result 0
  
: # separator 
  
  # With PS = 0.9, PR = 0.6, and PCM = 0.3
  # type1 Cache prob = (1-PCM)*PS, type1 disk = PCM*PS	
  # type2 prob = PR*(1-PS), and type3 = (1-PR)(1-PS)
  analyzestart -> (0.63)Cache + (0.27)Disk + (0.06)type2 + (0.04)type3;
  
  # Sending the results as a reply to protocol stack(PS) 
  # as requierd by the LQN language 
  Cache + Disk + type2 + type3 -> result;
  result[PS]		
  
-1  
#lqns Project.lqn >Project.txt 
#cd Project.d
#lqn2svg 
R 0 
$0=$N
#$threads
$thru $rt 
$uCGIApplication $uDBDisk $uDBP $uDBS 
$uProtocolStack $uWSDisk $uWSP  $uWebServer

-1
